--- mem0/memory/main.py
+++ mem0/memory/main.py
@@ -447,7 +447,7 @@
             else:
                 try:
                     # First try direct JSON parsing
-                    new_retrieved_facts = json.loads(response)["facts"]
+                    new_retrieved_facts = json.loads(response).get("facts", [])
                 except json.JSONDecodeError:
                     # Try extracting JSON from response using built-in function
                     extracted_json = extract_json(response)
-                    new_retrieved_facts = json.loads(extracted_json)["facts"]
+                    new_retrieved_facts = json.loads(extracted_json).get("facts", [])
         except Exception as e:
             logger.error(f"Error in new_retrieved_facts: {e}")
             new_retrieved_facts = []
@@ -541,7 +541,25 @@
                         returned_memories.append({"id": memory_id, "memory": action_text, "event": event_type})
                     elif event_type == "UPDATE":
-                        self._update_memory(
-                            memory_id=temp_uuid_mapping[resp.get("id")],
+                        # Check if the memory ID exists in the mapping
+                        memory_id_to_update = temp_uuid_mapping.get(resp.get("id"))
+                        if memory_id_to_update is None:
+                            # If memory doesn't exist, treat UPDATE as ADD
+                            logger.warning(f"Memory ID '{resp.get('id')}' not found in existing memories, treating UPDATE as ADD")
+                            memory_id = self._create_memory(
+                                data=action_text,
+                                existing_embeddings=new_message_embeddings,
+                                metadata=deepcopy(metadata),
+                            )
+                            returned_memories.append({"id": memory_id, "memory": action_text, "event": "ADD"})
+                        else:
+                            self._update_memory(
+                                memory_id=memory_id_to_update,
+                                data=action_text,
+                                existing_embeddings=new_message_embeddings,
+                                metadata=deepcopy(metadata),
+                            )
+                            returned_memories.append(
+                                {
+                                    "id": memory_id_to_update,
+                                    "memory": action_text,
+                                    "event": event_type,
+                                    "previous_memory": resp.get("old_memory"),
+                                }
+                            )
+                    elif event_type == "DELETE":
+                        # Check if the memory ID exists before deleting
+                        memory_id_to_delete = temp_uuid_mapping.get(resp.get("id"))
+                        if memory_id_to_delete is None:
+                            logger.warning(f"Memory ID '{resp.get('id')}' not found in existing memories, skipping DELETE")
+                        else:
+                            self._delete_memory(memory_id=memory_id_to_delete)
                             returned_memories.append(
                                 {
-                                    "id": temp_uuid_mapping[resp.get("id")],
+                                    "id": memory_id_to_delete,
                                     "memory": action_text,
                                     "event": event_type,
-                                    "previous_memory": resp.get("old_memory"),
                                 }
                             )
-                    elif event_type == "DELETE":
-                        self._delete_memory(memory_id=temp_uuid_mapping[resp.get("id")])
-                        returned_memories.append(
-                            {
-                                "id": temp_uuid_mapping[resp.get("id")],
-                                "memory": action_text,
-                                "event": event_type,
-                            }
-                        )
                     elif event_type == "NONE":
                         # Even if content doesn't need updating, update session IDs if provided
                         memory_id = temp_uuid_mapping.get(resp.get("id"))
                         if memory_id and (metadata.get("agent_id") or metadata.get("run_id")):
                             # Update only the session identifiers, keep content the same
                             existing_memory = self.vector_store.get(vector_id=memory_id)
+                            if existing_memory is None:
+                                logger.warning(f"Memory {memory_id} not found when trying to update session IDs")
+                            else:
-                            updated_metadata = deepcopy(existing_memory.payload)
-                            if metadata.get("agent_id"):
-                                updated_metadata["agent_id"] = metadata["agent_id"]
-                            if metadata.get("run_id"):
-                                updated_metadata["run_id"] = metadata["run_id"]
-                            updated_metadata["updated_at"] = datetime.now(pytz.timezone("US/Pacific")).isoformat()
-
-                            self.vector_store.update(
-                                vector_id=memory_id,
-                                vector=None,  # Keep same embeddings
-                                payload=updated_metadata,
-                            )
-                            logger.info(f"Updated session IDs for memory {memory_id}")
+                                updated_metadata = deepcopy(existing_memory.payload)
+                                if metadata.get("agent_id"):
+                                    updated_metadata["agent_id"] = metadata["agent_id"]
+                                if metadata.get("run_id"):
+                                    updated_metadata["run_id"] = metadata["run_id"]
+                                updated_metadata["updated_at"] = datetime.now(pytz.timezone("US/Pacific")).isoformat()
+
+                                self.vector_store.update(
+                                    vector_id=memory_id,
+                                    vector=None,  # Keep same embeddings
+                                    payload=updated_metadata,
+                                )
+                                logger.info(f"Updated session IDs for memory {memory_id}")
                         else:
                             logger.info("NOOP for Memory.")
                 except Exception as e:
@@ -1145,6 +1163,8 @@
         try:
             existing_memory = self.vector_store.get(vector_id=memory_id)
         except Exception:
             logger.error(f"Error getting memory with ID {memory_id} during update.")
+            return None
+        if existing_memory is None:
             return None
 
         new_metadata = deepcopy(metadata) if metadata is not None else {}
@@ -1161,11 +1181,11 @@
         # Preserve session identifiers from existing memory only if not provided in new metadata
         if "user_id" not in new_metadata and "user_id" in existing_memory.payload:
-            new_metadata["user_id"] = existing_memory.payload["user_id"]
+            new_metadata["user_id"] = existing_memory.payload.get("user_id")
         if "agent_id" not in new_metadata and "agent_id" in existing_memory.payload:
-            new_metadata["agent_id"] = existing_memory.payload["agent_id"]
+            new_metadata["agent_id"] = existing_memory.payload.get("agent_id")
         if "run_id" not in new_metadata and "run_id" in existing_memory.payload:
-            new_metadata["run_id"] = existing_memory.payload["run_id"]
+            new_metadata["run_id"] = existing_memory.payload.get("run_id")
         if "actor_id" not in new_metadata and "actor_id" in existing_memory.payload:
-            new_metadata["actor_id"] = existing_memory.payload["actor_id"]
+            new_metadata["actor_id"] = existing_memory.payload.get("actor_id")
         if "role" not in new_metadata and "role" in existing_memory.payload:
-            new_metadata["role"] = existing_memory.payload["role"]
+            new_metadata["role"] = existing_memory.payload.get("role")
 
@@ -1473,7 +1493,7 @@
             else:
                 try:
                     # First try direct JSON parsing
-                    new_retrieved_facts = json.loads(response)["facts"]
+                    new_retrieved_facts = json.loads(response).get("facts", [])
                 except json.JSONDecodeError:
                     # Try extracting JSON from response using built-in function
                     extracted_json = extract_json(response)
-                    new_retrieved_facts = json.loads(extracted_json)["facts"]
+                    new_retrieved_facts = json.loads(extracted_json).get("facts", [])
         except Exception as e:
             logger.error(f"Error in new_retrieved_facts: {e}")
             new_retrieved_facts = []
@@ -1572,7 +1592,15 @@
                         memory_tasks.append((task, resp, "ADD", None))
                     elif event_type == "UPDATE":
-                        task = asyncio.create_task(
+                        # Check if the memory ID exists in the mapping
+                        memory_id_to_update = temp_uuid_mapping.get(resp.get("id"))
+                        if memory_id_to_update is None:
+                            # If memory doesn't exist, treat UPDATE as ADD
+                            logger.warning(f"Memory ID '{resp.get('id')}' not found in existing memories, treating UPDATE as ADD (async)")
+                            task = asyncio.create_task(
+                                self._create_memory(
+                                    data=action_text,
+                                    existing_embeddings=new_message_embeddings,
+                                    metadata=deepcopy(metadata),
+                                )
+                            )
+                            memory_tasks.append((task, resp, "ADD", None))
+                        else:
+                            task = asyncio.create_task(
                             self._update_memory(
-                                memory_id=temp_uuid_mapping[resp["id"]],
+                                memory_id=memory_id_to_update,
                                 data=action_text,
                                 existing_embeddings=new_message_embeddings,
                                 metadata=deepcopy(metadata),
                             )
                         )
-                        memory_tasks.append((task, resp, "UPDATE", temp_uuid_mapping[resp["id"]])
+                            memory_tasks.append((task, resp, "UPDATE", memory_id_to_update))
                     elif event_type == "DELETE":
-                        task = asyncio.create_task(self._delete_memory(memory_id=temp_uuid_mapping[resp.get("id")]))
-                        memory_tasks.append((task, resp, "DELETE", temp_uuid_mapping[resp.get("id")]))
+                        # Check if the memory ID exists before deleting
+                        memory_id_to_delete = temp_uuid_mapping.get(resp.get("id"))
+                        if memory_id_to_delete is None:
+                            logger.warning(f"Memory ID '{resp.get('id')}' not found in existing memories, skipping DELETE (async)")
+                        else:
+                            task = asyncio.create_task(self._delete_memory(memory_id=memory_id_to_delete))
+                            memory_tasks.append((task, resp, "DELETE", memory_id_to_delete))
                     elif event_type == "NONE":
                         # Even if content doesn't need updating, update session IDs if provided
                         memory_id = temp_uuid_mapping.get(resp.get("id"))
                         if memory_id and (metadata.get("agent_id") or metadata.get("run_id")):
                             # Create async task to update only the session identifiers
                             async def update_session_ids(mem_id, meta):
                                 existing_memory = await asyncio.to_thread(self.vector_store.get, vector_id=mem_id)
+                                if existing_memory is None:
+                                    logger.warning(f"Memory {mem_id} not found when trying to update session IDs (async)")
+                                    return
                                 updated_metadata = deepcopy(existing_memory.payload)
                                 if meta.get("agent_id"):
                                     updated_metadata["agent_id"] = meta["agent_id"]
                                 if meta.get("run_id"):
                                     updated_metadata["run_id"] = meta["run_id"]
                                 updated_metadata["updated_at"] = datetime.now(pytz.timezone("US/Pacific")).isoformat()
 
                                 await asyncio.to_thread(
                                     self.vector_store.update,
                                     vector_id=mem_id,
                                     vector=None,  # Keep same embeddings
                                     payload=updated_metadata,
                                 )
                                 logger.info(f"Updated session IDs for memory {mem_id} (async)")
 
                             task = asyncio.create_task(update_session_ids(memory_id, metadata))
                             memory_tasks.append((task, resp, "NONE", memory_id))
                         else:
                             logger.info("NOOP for Memory (async).")
